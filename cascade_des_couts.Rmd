---
title: <span style="font-size:150%; font-variant:small-caps; font-style:italic">Construction de la cascade <br/> des coûts sous R</span>
author:  |
  <div class="title"><span style="font-size:125%; font-variant:small-caps; font-style:normal">Ismaila DJIMERA</span><br><br>
  [<img src="images/logo.png", width='50%'>](https://legroupe.laposte.fr/)</div>
date: "20 février 2018"
output: 
  html_document: 
  #prettydoc::html_pretty:
    theme: cosmo
    css: notebook.css
    highlight: pygments
    self_contained: yes
    code_folding: hide
    toc_float: true
    toc: yes
    toc_depth: 6
    pandoc_args: [
      "-M3GB","+RTS", "-K64m",
      "-RTS"
    ]
    #toc_float: no
---


```{r eval=FALSE, include=FALSE}
library(htmltools)
htmltools::img(src = knitr::image_uri(file.path("logo.png")), 
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:10px;')
```

---


```{r message=FALSE, warning=FALSE,results = "hide"}

# liste des librairies nécessaires
list.of.packages = c('tidyverse','ggplot2','readr', 'stringi', 'knitr', 'DT',
                     'sp','kableExtra','data.table','microbenchmark','plotly')



# Install les packages (s'ils ne sont pas déjà installés)
inst <- list.of.packages %in% installed.packages()
if(length(list.of.packages[!inst]) > 0) install.packages(list.of.packages[!inst],
                                                         repos='http://cran.us.r-project.org')

# Chargement des librairies
lapply(list.of.packages, require, character.only=TRUE)



# Définition de l'espace de travail
setwd("W:/01 - Projets/DEV/Cascade")

options(digits=15)
```


# Introduction
Ce document explique les différentes étapes de la construction de la cascade des coûts. Pour faciliter l'explication du processus, nous avons découpé les activités en 3 classes :

* `CDO`: Ce sont les charges directes opérationnelles. Elles représentent les activités sur lesquelles les charges des autres activités doivent être ventilées. Elles sont indexées par les codes 1 à 25.
* `CIO` : Charges indirectes opérationnelles. Ce sont des charges à ventiler selon des codes temps. Elles sont indexées par les codes 26 à 35.
* `CSS` : Charges de Structures et de support. Ce sont les autres charges qui se ventilent selon les clés temps ou les clés au taux de frais ou encore les deux. Elles sont indexées par les codes 36 à 61.

# Importation des fichiers de paramétrage
Dans un premier temps, on importe les fichiers de paramétrage qui seront utilisés dans le calcul des clés de répartition des charges. Ici, nous importons les fichiers suivant :


* Le paramétrage pour le calcul des clés temps
* Le paramétrage des types de clés par code activité
* Les montants du CICE par TCACAA de l'année
* Le paramétrage des marquages d'activités dans lequel tout se repose sur les codes activités
* Le paramétrage pour la construction des clés de taux de frais qui sont des clés qui se baseront sur les charges directes et les charges issues de la ventilation des coûts via les clés temps.
* Le paramétrage de la FLDC qui indique les rubriques corp appartenant ou non aux charges de personnel ou d'immobilier
* Les données brutes : Pour ces données, dans un premier temps nous avons utilisé les charges après retraitement. Ceci sera corrigé après les vérifications pour stabiliser l'outil.
* Le paramétrage des valeurs en dur notamment les charges d'hebergement des facteurs ou la formation LCB.

À noter que ces données pour faciliter le traitement dans l'outil seront au format csv et le séparteur des décimal sera le "." .

L'ensemble de ces paramétrages se fera dans un unique fichier Excel. Ce fichier contient une macro encapsulée dans un bouton pour valider les paramétrages afin que ces derniers puissent être utilisés dans le traitement de la cascade.

```{r message=FALSE, warning=FALSE}

################################
# Le paramétrage des clés temps#
################################

param_temps <- read.csv2("param/param_temps.csv", header = TRUE, 
    sep = ";",dec = ",", encoding = "ISO-8859-2"
    )


param_temps <- param_temps %>%
    mutate(temps_min = if_else(is.na(temps_min), 0, temps_min))%>%
  filter(Code_Activite>0)


###########################################
# Le paramétrage des clés au taux de frais#
###########################################

param_tf <- read.csv2("param/param_tf.csv", header = TRUE, 
    sep = ";",dec = ",", encoding = "ISO-8859-2"
    )


param_type_cle <- read.csv2("param/param_type_cle.csv", header = TRUE, 
    sep = ";",dec = ",", encoding = "ISO-8859-2"
    )


######################
# La base de marquage#
######################

marquage <- read.csv2("param/marquage.csv", header = TRUE, 
    sep = ";",dec = ",", encoding = "ISO-8859-2"
    )

###########
# Le CICE #
###########

data_cice <- read.csv2("param/data_cice.csv", header = TRUE, 
    sep = ";",dec = ",", encoding = "ISO-8859-2"
    )



############################################
# Les rubrique corp concernées par la FLDC #
############################################

fldc <- read.csv2("param/data_FLDC.csv", header = TRUE, 
    sep = ";",dec = ",", encoding = "ISO-8859-2"
    )


#Part_CVAE<- 47222150 #A répartir selon une clé basée sur les charges de personnels
#Part_CFE <- 18473794 #A répartir selon une clé basée sur les loyers des charges et compléments de loyers

###################
# Base de charges #
###################

data <- read.csv2("param/data.csv", header = TRUE, 
    sep = ";",dec = ",", encoding = "ISO-8859-2"
    )%>%
  mutate(Chg_av_CICE_non_prod_form=ifelse(Rubrique_Corp%in%c("R63725LPA","R63730LPB"),0,Chg_av_CICE_non_prod_form) )
#De la base de charge on doit supprimer les charges sur RETRAITEMENT TAXE SUR SALAIRE et RETRAITEMENT DE LA TVA  




#####################################################################################################################
###################
# Valeurs en dur  #
###################

param_en_dur <- read.csv2("param/param_en_dur.csv", header = TRUE, 
    sep = ";",dec = ",", encoding = "ISO-8859-2"
    )

#param_en_dur <- read_delim("param/param_en_dur.csv", 
    #";", escape_double = FALSE, locale = locale(encoding = "ISO-8859-2"), 
    #trim_ws = TRUE)

#Valeurs en dur pour le traitement activité 30
charge_heberge_facteur<-param_en_dur[which(param_en_dur$Nom=="charge_heberge_facteur"),]$Valeur
#charge_heberge_facteur=12537410.3015909

# Formation
prestation_formation<-param_en_dur[which(param_en_dur$Nom=="prestation_formation"),]$Valeur
Formation_LCB<-param_en_dur[which(param_en_dur$Nom=="Formation_LCB"),]$Valeur

#prestation_formation=5308121 # A soustraire des charge du code 41
#Formation_LCB=12625761 # A allouer à l'activité 7

# FLDC
Part_CVAE<-param_en_dur[which(param_en_dur$Nom=="Part_CVAE"),]$Valeur
Part_CFE <-param_en_dur[which(param_en_dur$Nom=="Part_CFE"),]$Valeur


#Part_CVAE<- 47222150 #A répartir selon une clé basée sur les charges de personnels
#Part_CFE <- 1847379 #A répartir selon une clé basée sur les loyers des charges et compléments de loyers4 #


#parametrage des listes 
CDO =c('code_1','code_2','code_3','code_4','code_5','code_6','code_7','code_8','code_9','code_10',
'code_11','code_12','code_13','code_14','code_15','code_16','code_17','code_18','code_19','code_20','code_21',
'code_22','code_23','code_24','code_25')

CIO_int<-c('Code_Activite','weight_code_26','weight_code_27','weight_code_28','weight_code_29',
                           'weight_code_30',
                           'weight_code_31','weight_code_32','weight_code_33','weight_code_34','weight_code_35')

```

# Marquage de la base de charges pilotées

Le réseau envoie une base de charges qui comporte un certain nombre d'élements. Cette base de charge est préalablement marquée par le réseau grâce au `CAA`, le `TCA` et la `rubrique Corp`.

Le marquage de la base des charges consiste à associer à chaque opération le code activité correspondant. Pour ce faire, nous avons besoin de 4 éléments qui nous permettent de construire un identifiant. Ces 4 éléments sont la concaténation de :

* Le code du processus cascade qui est au format `PCXXX` X représentant un chiffre
* Le code de l'activité métier qui est au format `AMXXXX`
* Le code de l'activité Cascade qui est au format `ACXX`
* Le code du label Analytique qui est au format `AAAAAA` A représentant une lettre.

Ces 4 éléments sont issus d'un marquage qui est réalisé par le réseau en se basant sur le **CAA**, le **TCA** et la **rubrique Corp**. 

<center>
![](images/marquage_1.PNG)
</center>

Grâce à ces 4 éléments, on construit la clé au format **PCXXXAMXXXXACXXAAAAAA**. De là, nous associons à chaque identifiant l'activité correspondante.

<center>
![](images/marquage_2.PNG)
</center>


```{r}
table <- marquage%>%
  distinct(Lib_Code,Code_manuel)%>%
  select(Lib_Code,Code_manuel)

datatable(table, rownames = FALSE, colnames =c( "Lib_Code", "Code_manuel"),
          options = list( order = list(list(1, 'asc')), 
  pageLength = 10, 
  search = list(search = '')))
```


# Traitement du CICE

Dans cette partie, il s'agit de construire les charges après retraitement du CICE , du non productif et formation.
Nous partons de la base de chargesbrute dans laquelle nous avons les charges avant CICE, le non productif et la formation. Cette valeur est indiquée dans la variable **Chg_av_CICE_non_prod_form**.</br>

## Méthodologie de calcul des charges après retraitement de CICE et du non productif et formation

Le CICE (Crédit Impôt Compétitivité Emploi) est un système de qui permet de réduire les charges payées par les entreprise pour les personnels qui sont rémunérés moins de 2,5 fois le SMIC. Le périmètre des personnels concernés est défini à La Poste par la DRHRS à partir des éléments de rémunération versée aux personnels pendant la période considérée.</br>

Dans les faits, un salaire inférieur à 2,5 fois le SMIC rapporte un crédit d'impôt de 7 % si l'agent est en Corse ou en Métropole et 9 % s'il est dans les DOM. </br>

La DRAIE continue de faire la ventilation analytique du CICE : sur les CAA et TCA. Seule la DRAIE utilise cette ventilation analytique pour la CR et l'allocation des coûts du Réseau.

Nous allons calculer les clés de ventilation du CICE, le non productif et la formation rappelons que le CICE, le non productifet la formation ne concernent que les activités de nature `Charges de Personnel`. Par CAA et TCA, nous allons calculer le montant du CICE, du non productif et de la formation que nous retirerons des charges initiales.

La méthodologie consiste simplement à calculer les clés de répartition de ces charges et de les enlever de la base de charges brute.
```{r message=FALSE, warning=FALSE}

# Création du TCACAA dans la base des charges
data<-data%>%
  mutate(TCACAA=stri_replace_all_fixed(paste(TCA,CAA), " ", ""))%>%
  mutate(Nat_chg_TCACAA=stri_replace_all_fixed(paste(Nat_charge,TCA,CAA), " ", ""))
  

cice_agg<-data%>%
  filter(Nat_charge=="1.2.2 - CHARGES - PERSONNEL")%>%
  group_by(Nat_chg_TCACAA,TCACAA)%>%
  summarise(cice_agg=sum(Chg_av_CICE_non_prod_form) )%>%
  left_join(data_cice)%>%
  mutate_all(funs(replace(., is.na(.), 0)))


sum_cice=sum(cice_agg$cice)

montatnts_CICE<-sum(data[which(data$Lib_Rubrique_Corp %in%c("CICE FONCTIONNAIRES","CICE SALARIES CDI","CICE SALARIES CDD","CICE PROVISIONNE")),]$Chg_av_CICE_non_prod_form)

cice_agg<-cice_agg%>%
  mutate(cle_a_retirer=cice/sum_cice)%>%
  mutate(mnt_cice_a_retirer=-cle_a_retirer*montatnts_CICE)%>%
  mutate(taux_cice=(cice_agg-mnt_cice_a_retirer)/cice_agg)%>%
  mutate_all(funs(replace(., is.na(.), 0)))%>%
  select(Nat_chg_TCACAA,taux_cice)


data<-data%>%
  left_join(cice_agg, by="Nat_chg_TCACAA")%>%
  mutate(taux_cice=ifelse(is.na(taux_cice), 1, taux_cice))#%>%
  #mutate(charge_Ap_Ret=Chg_av_CICE_non_prod_form*taux_cice)

# Calcul des clés formations et non productif

data<-data %>% left_join(marquage[,9:13])%>%
              mutate(code=stri_replace_all_fixed(paste('code_',Code_manuel), " ", ""))
  
 
 
 total_form_non_prod<-data%>%
   filter(#Nat_charge=="1.2.2 - CHARGES - PERSONNEL",
          Lib_TCA=="DT Direction Territoriale",Lib_CAA %in% c("FORMATION","NON  PRODUCTIFS"))%>%
   summarise(total_form_non_prod=sum(Chg_av_CICE_non_prod_form))
 
 total_form_non_prod<-total_form_non_prod$total_form_non_prod
 
 
 formation<-data%>%
   filter(Nat_charge=="1.2.2 - CHARGES - PERSONNEL",
          Lib_TCA=="DT Direction Territoriale",
          Code_manuel %in% c(3,10,38))%>%
   group_by(#Lib_TCA, Code_manuel, 
            Lib_Code)%>%
   summarise(charges=sum(Chg_av_CICE_non_prod_form))%>%
   mutate(poids=charges/sum(charges))%>%
   mutate(charge_int=ifelse(Lib_Code!="ST - Autres",
                            poids*total_form_non_prod,
                            poids*total_form_non_prod-total_form_non_prod))%>%
   select(Lib_Code,charge_int)
 
 charges_code<-data%>%
   filter(Code_manuel %in% c(3,10,38))%>%
   group_by( 
            Lib_Code)%>%
   summarise(charges_tot_code=sum(Chg_av_CICE_non_prod_form))

 data<-data%>%
   left_join(formation, by="Lib_Code")%>%
   left_join(charges_code,by="Lib_Code")%>%
   mutate(montant_no_prod_code=ifelse(is.na(charges_tot_code),0,charge_int*Chg_av_CICE_non_prod_form/charges_tot_code ))%>%
   mutate(#Ch.AP.Ret
          Ch_AP_Ret=ifelse(Rubrique_Corp%in%c("R75850A","R75850B","R75850C","R75851A"),0,
                           (Chg_av_CICE_non_prod_form*taux_cice)+montant_no_prod_code))
 
 rm("formation", "charges_code","cice_agg","total_form_non_prod", "sum_cice", "montatnts_CICE" )
 
 #data$verif=data$Ch_AP_Ret-data$Ch.AP.Ret
 
 #verif<-data%>%filter(Ch.AP.Ret!=Ch_AP_Ret)
```



# Construction des clés 
Nous allons expliciter ici la construction des clés temps et des clés au taux de frais.


## Construction des clés temps pour les activités à ventiler

### Méthodologie
Dans cette partie, nous construirons les clés temps et par la même occasion les coûts intermédiaires ventilés grâce à ces clés temps.
Nous partons de la matrice de paramétrage qui a été importée ci-haut.
![](images/param_temps.PNG)
Le fichier de paramétrage contient les éléments suivants :

* Les 2 premières colonnes décrivent les codes et les libellés pour lesquels on doit calculer les clés temps. Les codes en ligne contiennent à la fois des activités opérationnelles COD, mais aussi les autres activités qui doivent être ventilées avec les clés temps.
* la 3 ème colonne décrit les temps agent alloué à l'activité
* les autres colonnes décrivent COI et les CSS qui doivent être ventilées sur les activités en lignes. Ainsi si pour une colonne on met 'o' pour une activité cela signifie que les charges de cette activité doivent être ventilées sur l'activité en ligne correspondante.

Cette façon de faire, suppose donc que nous devons connaître en amont les charges des différentes activités qui sont en colonne. Cette information se trouve dans la base de charge avec la colonne **Ch_AP_Ret** qui représente les charges après retraitement.
Mais nous la calculerons dans la suite à partir des données directes issues de la base de charge
Essayons de formaliser mathématiquement le calcul des clés temps.


* Soit $K=(1,...,k...,K)$ l'ensemble des activités sur lesquels on doit calculer des clés temps
* Soit $J=(1,...,j...,J)$ l'ensemble des activités pour lesquels on doit ventiler des charges.
* Soit $T_{k}$ le temps alloué à l'opération $k$
* Soit $\mathbb{1}_{k}(o)$ la fonction indicatrice qui indique si une activité de l'ensemble $J$ doit être ventilé sur l'activité $k$ de l'ensemble $K$. Cette fonction représente le fichier de paramétrage avec les options "o"
* Soit $W_{k}^{j}$ la clé temps de l'activité $j$ à ventiler sur l'activité $k$ 

$$ W_{k}^{j}=\frac{T_{k}*\mathbb{1}_{k}(o) }{\sum_{i \in (\mathbb{1}_{k}(o)} \mathbb{1}_{i}(o)*T_{i} }$$
Traduit litéralement, cette formule signifie que le poids d'une activité est égal au rapport de son temps sur la somme des temps des activité sur laquelle la charge doit être ventilée.

Ce poids est appliqué à la charge après traitement des opérations à ventiler. Soit $Charge_{k}^{j}$ la charge de l'opération $j$ à ventiler sur l'opération $k$, nous aurons donc :
$$ChargeTA_{k}^{j}=Charge_{k}^{j}*W_{k}^{j}$$



```{r message=FALSE}
# Jointure de la table des données avec la table de marquage et création de la variable de code
data<-data %>%mutate(#code=stri_replace_all_fixed(paste('code_',Code_manuel), " ", ""),
                     Ch_AP_Ret=ifelse(is.na(Ch_AP_Ret),0,Ch_AP_Ret))%>%
  filter(is.na(Code_manuel)==0)

# Calcul des charges intermédiaires pour la construction des taux de frais
#Cette table sera utilisée dans la suite pour le calcul des clés au taux de frais
Charges_for_TA<-data%>% 
    group_by(code)%>%
     summarise(charges_TA=sum(Ch_AP_Ret))

a<-as.data.frame(t(Charges_for_TA))
a<-a[-1,]
colnames(a)<-t(Charges_for_TA[,1])
a<- data.frame(lapply(a, function(x) as.numeric(as.character(x))))


## Calcul des charges 
drop_var<-names(a) %in%CDO
a<-a[!drop_var]


#Stockage des variables concernées : ce sont les variables en colonne
liste_col=colnames(param_temps)[4:length(colnames(param_temps))]





cle_temps<-param_temps[,1:2]

#Boucle pour construire la variable de clé temps en fonction des effectifs temps
for (i in 1:length(liste_col))
{
  # Nouvelle variable de clé
  var<-stri_replace_all_fixed( paste("weight_",liste_col[i]), " ", "")
  #Variable sur laquelle calculer la clé
  code<-stri_replace_all_fixed(liste_col[i]," ","")
    sum_temps=sum(param_temps[which(param_temps[[paste(code)]]=="o"),]$temps_min)
  count_oui=nrow(param_temps[which(param_temps[[paste(code)]]=="o"),])
  # Construction de la variable
  cle_temps[[paste(var)]]=ifelse(param_temps[[paste(code)]]!="o",0,
                              param_temps$temps_min/sum(param_temps[which(param_temps[[paste(code)]]=="o"),]$temps_min))
#}
  # Traitement des cas particuliers où un seul poids existe, on fait le rapport sur la somme des effectifs
  cle_temps[[paste(var)]]<-ifelse(param_temps[[paste(code)]]=="o" 
                                    & param_temps$Code_Activite==11 
                                    & count_oui==1
                                ,(param_temps$temps_min/sum(param_temps$temps_min))
                                ,cle_temps[[paste(var)]])
 
}



```
### Les traitements spécifiques
Toutes les activités ne suivent pas la même logique mathématique énoncée ci-haut pour calculer leurs clés temps. Il existe des cas spécifiques ; ces derniers sont :

* La charge 32: `Directeur de Secteur (DS)` est répartie via une clé temps agent des personnes encadrées. Cette clé est directement intégrée dans la table de paramétrage des clés temps en dur.
* La charge 33: `Responsable Espace Comercial (REC)` est répartie via une clé temps agent des personnes encadrées. Cette clé est directement intégrée dans la table de paramétrage des clés temps en dur.
* La charge 30 `CIE - Loyers et Charges Immobilicres (hors Cplts de Loyers)`, pour cette charge le réseau donne un montant qui se déverse sur l'hébergement des facteurs, ainsi on doit calculer les clés de sorte à intégrer cette partie et avoir une répartition à 100%. La valeur fournie par le réseau est stockée en dur dans la variable `charge_heberge_facteur` 
* La charge 41 `SSM - Formation` c'est le même pricipe que la charge 30 , sauf qu'on doit retirer de la charge les prestation de formation, ensuite allouer un montant à la formation LBC et répartir le reste de sorte à tenir 100% avec la charge total en dehors des prestations de formation.

```{r message=FALSE, warning=FALSE}
## traitement spécifique
cle_temps$weight_code_32<-param_temps$code_32
cle_temps$weight_code_33<-param_temps$code_33

# traitement des clé mixtes

# Pour le code 30 on sait 
cle_temps<-cle_temps%>%
  mutate(weight_code_30=ifelse(is.na(weight_code_30),weight_code_30,weight_code_30*(a$code_30-charge_heberge_facteur)/a$code_30))

#sum(cle_temps$weight_code_30,na.rm=T)
cle_temps<-cle_temps%>%
  mutate(weight_code_30=ifelse(Code_Activite==2,1-sum(cle_temps$weight_code_30,na.rm=T),weight_code_30))
#sum(cle_temps$weight_code_30,na.rm=T)

# Pour le code 41
# on supprime les charges à enlever
a<-a%>%
  mutate(code_41=code_41-prestation_formation)

cle_temps<-cle_temps%>%
  mutate(weight_code_41=ifelse(is.na(weight_code_41),weight_code_41,weight_code_41*(a$code_41-Formation_LCB)/a$code_41))
#sum(cle_temps$weight_code_41,na.rm=T)

cle_temps<-cle_temps%>%
  mutate(weight_code_41=ifelse(Code_Activite==7,1-sum(cle_temps$weight_code_41,na.rm=T),weight_code_41))

#sum(cle_temps$weight_code_41,na.rm=T)

# Conversion des variables en numerique
#cle_temps<-cle_temps%>%mutate_each(funs(as.numeric), starts_with("weight_"))
cle_temps<-cle_temps%>%mutate_at(vars(starts_with("weight_")), as.numeric)
```

### Calcul des charges réparties aux clés temps : Répartition primaire

Après avoir calculé les clés temps et traité les cas spécifiques, nous pouvons calculer les charges ventilés aux clés temps. Nous appliquons juste le même principe énoncé ci-haut en multipliant les charges par les clés obtenues. C'est une répartition sur les activités opérationnelles sans prendre en compte la répartition sur les activités non opérationnelles.


```{r message=FALSE, warning=FALSE}

###################################################################################################################
#Boucle pour construire la variable des charges intermédiaires avec les clés temps en fonction des effectifs temps#
###################################################################################################################
for (i in 1:length(liste_col))
{
  # Nouvelle variable de clé
  var<-stri_replace_all_fixed( paste("weight_",liste_col[i]), " ", "")
  #Variable sur laquelle calculer la clé
  code<-stri_replace_all_fixed(liste_col[i]," ","")
  # Construction de la variable
  param_temps[[paste(var)]]=a[1,i]*cle_temps[[paste(var)]]
}

```





Ci-dessous, la matrice des clés temps
```{r message=FALSE, warning=FALSE}
kable(cle_temps, "html",caption = "Matrice des clés temps") %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  scroll_box(width = "1000px", height = "500px")

```

Ci-dessous la matrice des charges obtenus par ventilation avec les clés temps
```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
kable(param_temps, "html",caption = "Matrice des charges obtenus par ventilation avec les clés temps") %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  scroll_box(width = "1000px", height = "500px")
```


Le programme ci-dessus nous a permis de calculer les clés temps, mais aussi les charges intermédiaires liées à ces clés temps. 

Dans la partie qui suit, nous allons calculer les clés au taux de frais qui dépendent des charges intermédiaires qui ont été calculées à partir des temps.

## Calcul des clés taux de frais

### Méthodologie 
Les clefs basées sur les coûts (taux de frais) doivent être calculées à partir des coûts directs des activités opérationnelles (codes 1 à 25) + charges indirectes réparties (codes 26 à 35).
Les coûts directs des activités opérationnelles ont été identifiés via le mécanisme de marquage. Nous allons coupler cette information avec les coûts indirectes issues de la ventilation via les clés temps pour déterminer les clés au taux de frais.


<center>
![](images/param_tf.PNG)
</center>



Ces clés au taux de frais s'appliquent à des activités opérationnelles. Pour définir les opérations sur lesquelles ils s'appliquent, nous utilisons un autre fichier de paramétrage similaire au paramétrage des clés temps.<br/>
Voici les étapes de calcul des clés au taux de frais sur les différentes activités qui doivent en bénéficier.

1. On calcule les coûts directes des opérations ayant les codes 1 à 25
2. On calcule les coûts indirectes issues de la répartition via les clés temps pour les codes 11 à 20
3. On somme les coûts directs avec les coûts indirects des opérations de code 1 à 25 pour les charges sur les opérations de 26 à 35.
4. On importe le paramétrage des taux de frais.
5. On calcule le poids.


Soit $\mathbb{1}_{j}(o)$ l'indicatrice qui indique si une charge doit être déversée ou non sur les activités opérationnelles. On note $CDI^{j}$ les charges directes et indirectes de l'activité opérationnelle $j$.<br/> On note $Wtf_{k}^{j}$ la clé au taux de frais de l'activité k sur l'activité j. $Wtf_{k}^ {j}$ est définis par : 

$$ Wtf_{k}^{j}=\frac{CDI^{j}}{\sum_{i}(\mathbb{1}_{i}(o))*CDI^{i}} $$

<center>
![](images/TF.jpg){width=50%}
</center>

```{r message=FALSE}

## Création de la table des coûts directes des activités opérationnelles
cout_dir_op<-Charges_for_TA[which(Charges_for_TA$code %in% CDO),] #c('code_1','code_2','code_3','code_4','code_5','code_6','code_7','code_8','code_9','code_10')),]

# calcul des coûts indirectes
couts_indir<-param_temps%>%filter(Code_Activite%in% c(1:25))%>%
                            select(.dots = CIO_int)
names(couts_indir)<-CIO_int

# Calcul des coûts indirecte
couts_indir$code<-stri_replace_all_fixed( paste("code_",couts_indir$Code_Activite), " ", "")

# jointure des coûts directes avec les coûts indirectes
couts_dir_indir<-full_join(cout_dir_op,couts_indir)
couts_dir_indir<- arrange(couts_dir_indir, code)
drop.cols<-"Code_Activite"
couts_dir_indir<-couts_dir_indir%>%select(-one_of(drop.cols))

# Remplacement par zéros des coûts manquants
couts_dir_indir[is.na(couts_dir_indir)] <- 0
couts_dir_indir<-couts_dir_indir%>%
  mutate(charges=rowSums(couts_dir_indir[,2:12]))%>%
  select(code,charges)

  
## Utilisation du paramétrage des clés taux de frais
param_tf<-param_tf%>%
  mutate(code=stri_replace_all_fixed( paste("code_",Code_Activite), " ", ""))%>%
  filter(code %in% couts_indir$code)%>%
  arrange(code)

couts_dir_indir<-left_join(couts_dir_indir,param_tf)

rm("couts_indir", "cout_dir_op")

```
 
Après avoir arrangé les tables on peut procéder au calcul des clés au taux de frais.

```{r message=FALSE}

liste_col=colnames(couts_dir_indir)[5:(length(colnames(couts_dir_indir)))]

cle_tf<-couts_dir_indir[,c(1,3,4)]
#Boucle pour construire la variable de clé temps en fonction des effectifs temps
for (i in 1:length(liste_col))
{
  # Nouvelle variable de clé
  var<-stri_replace_all_fixed( paste("weight_",liste_col[i]), " ", "")
  #Variable sur laquelle calculer la clé
  code<-stri_replace_all_fixed(liste_col[i]," ","")
  # Construction de la variable
  cle_tf[[paste(var)]]=ifelse(couts_dir_indir[[paste(code)]]!="o",0,
                              couts_dir_indir$charges/sum(couts_dir_indir[which(couts_dir_indir[[paste(code)]]=="o"),]$charges))
  
}



```


### Traitement spécifique de la DPOM COrse 

La clé taux de frais qui est calculé ci-haut pour la l'activité *ST - Transverses en DPOM-DCR* n'est pas bonne, cette clé doit être calculé dur la base de la répartition des charges après retraitement sur ls activités pour lesquelles elle doit se ventiler. Le programme ci-dessous va corriger cette clé.

```{r message=FALSE, warning=FALSE}

#Calcule des charges directes sur la DPOM CORSE
dpom<-data%>%filter(Code_manuel %in% c(1,5,7,8,9,12),
                    Ste>6000 )%>%
             group_by(code)%>%
  summarise(charges_dpom=sum(Ch_AP_Ret))%>%
  mutate(cle_dpom=charges_dpom/sum(charges_dpom))

# Correction de la clé
cle_tf$weight_code_36=ifelse(cle_tf$code==dpom$code,dpom$cle_dpom,cle_tf$weight_code_36)            

```


```{r echo=FALSE}

#kable(couts_dir_indir[,-c(5:40)], format = "markdown")
kable(cle_tf, "html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  scroll_box(width = "900px", height = "500px")

#datatable(couts_dir_indir[,-c(5:40)], rownames = FALSE)
```

## Calcul des clés finales : Répartition secondaire

Dans les étapes précédentes, nous avons calculé les clés au taux de frais et les clés au temps. Rappelons que l'objectif de la cascade est de déverser sur les activités opérationnelles toutes les charges des autres activités.


### Méthodologie

Nous avons vu avec les clés temps que certaines activités se déversent sur d'autres activités non-opérationnelles. Ansi certaines `CIO` sont répartis sur d'autres `CIO` qui sont eux-mêmes répartis sur les `CDO`. Il convient donc de mettre à jour les clés sur les `CIO` des activités qui ont un bout qui est réparti sur les autres `CIO`.<br/>
Dans cette partie, nous allons nous atteler à cette tâche pour obtenir les clés finales sur les activités opérationnelles.

```{r}
# On va créer une matrice de clé qui combine les clés au tausx de frais et les clés temps
cle_fin<-cle_temps

act_tf<-param_type_cle%>%
        filter(type_cle%in%c("taux de frais","temps et taux de frais"))%>%
        mutate(var=stri_replace_all_fixed( paste("weight_",Code), " ", ""))%>%
        select(var)

list_col<-act_tf$var

drop_var<-names(cle_fin) %in%list_col
cle_fin<-cle_fin[!drop_var]

# Découpage pour ordonner par code 
mystrsplit <- function(x, pattern, part=2){
  return(strsplit(x, pattern)[[1]][part])
}
# Vectorize it so that it can handle vector arguments of x
mystrsplit <- Vectorize(mystrsplit, vectorize.args = "x")

cle_tf<- cle_tf%>%mutate(Code_Activite=as.numeric(mystrsplit(code, '\\_', 2)))%>%
                  arrange(Code_Activite)



dat1<-cle_tf[,list_col]
dat2 <- data.frame(matrix(nrow = nrow(cle_fin)-nrow(dat1), ncol = ncol(dat1)))

names(dat2) <- names(dat1)

dat<-bind_rows(dat1, dat2)

cle_fin<-cbind(cle_fin,dat)

# Ordonner les colonnes
cle_fin<-cle_fin[,order(colnames(cle_fin))]

# Nettoyage de la mémoire
rm("dat1", "dat2", "dat","act_tf")
```

On peut commencer le calcul à proprement dit des clés finales. Mais avant de commencer, on va traiter des cas spécifiques. Il s'agit des clés avec les codes 50 et 52. Ces derniers se répartissent en parti grâce aux clés temps sur l'activité 11 puis le reste est réparti au taux de frais.

```{r}
# on sait que pour les activités 50 et 52, une partie se répartie via le temps et le reste se réparti avec les clés taux de frais. Voici le traitement de cette règle:

cle_temps_heb=cle_temps[which(cle_temps$Code_Activite==11),]$weight_code_50
cle_fin<-cle_fin%>%
  mutate(weight_code_50=ifelse(is.na(weight_code_50),weight_code_50,weight_code_50*(1-cle_temps_heb)))

cle_fin[which(cle_fin$Code_Activite==11),]$weight_code_50=cle_temps_heb
#sum(cle_fin$weight_code_50,na.rm=T)

cle_fin<-cle_fin%>%
  mutate(weight_code_52=ifelse(is.na(weight_code_52),weight_code_52,weight_code_52*(1-cle_temps_heb)))

cle_fin[which(cle_fin$Code_Activite==11),]$weight_code_52=cle_temps_heb
#sum(cle_fin$weight_code_52,na.rm=T)


```

Une fois ces cas gérés, nous passons au traitement des charges qui se déversent sur d'autres charges non-opérationnelles. Nous en profitons pour créer en même temps la table des clés finales.<br/>
Avant de commencer ce traitement à proprement dit, essayons de formaliser concrétement ce que nous faisont dans cette partie.

* On note $W^{ij}_{CDO-CIO}$  la clé primaire de la CIO $j$ qui se déverse dans un CDO $i$.
* On note $W^{jk}_{CIO-CIO}$  la clé primaire de la CIO $j$ qui se déverse dans un CIO $k$.

La clé finale de l'activité j sur l'activité opérationnelle i est données par :

$$ W^{ij}_{fin}=W^{ij}_{CDO-CIO} + \sum_{k}W^{jk}_{CIO-CIO}*W^{ik}_{CDO-CIO}  $$

Ce formalise suppose un ordre de traitement des clés pour tenir compte des cas d'imbrication.
Dans le cas de la cascade en date de février 2018, seul l'activité 30 présente une imbrication de clés ainsi, il convient de traiter cette activité en premier et de mettre à jour les clés primaires avant le calcul de la clé finale des autres CIO.


```{r message=FALSE, warning=FALSE}

# Selection des codes activité 1 à 25: les COD 
# C'est la table de la répartition sur les activités opérationnelles
# Ces clés ne font pas 100% car il y a une partie qui va se déverser sur les activités non opérationnelles
cle_ini<-cle_fin%>%
  filter(Code_Activite%in%c(1:25))%>%
  arrange(Code_Activite)

# On remplace les valeurs manquantes par zeros
cle_ini[is.na(cle_ini)]<-0

# On selectionne clés sur les COD des activités COI qui se déversent dans d'autres COI. Voir si on ne peut pas les mettre en paramètre.
# C'est la répartion sur les activités opérationnelles des activités non opérationnelles sur lesquelles se déversent d'autres activités non opérationnelles
cle_int<-cle_ini%>%
  select(c("weight_code_30",
            "weight_code_32",
            "weight_code_33",
            "weight_code_34",
            "weight_code_35",
            "weight_code_38",
            "weight_code_39",
            "weight_code_40",
            "weight_code_41",
            "weight_code_45"))
  
# transoposition de la matrice pour faciliter les opérations de calcul
cle_int<-as.data.frame(t(cle_int))

# Clé des COI qui se déversent sur les autres COI
cle_venti<-cle_temps%>%
  filter(Code_Activite%in%c(30,
                          32,
                          33,
                          34,
                          35,
                          38,
                          39,
                          40,
                          41,
                          45))%>%
  arrange(Code_Activite)%>%
  select(3:7)
  
cle_venti[is.na(cle_venti)]<-0  

# Append des deux tables 
cle_venti<-cbind(cle_venti,cle_int)


## Cette fonction permet de calculer la clé correcte des COD pour les COI qui se déversent sur d'autre COI
correct_cle <- function(data, cle){
var<-data[[paste(cle)]]
test<-data%>%
          mutate_at(vars(starts_with("V")), funs(.*var))
          #mutate_each(funs(.*var), starts_with("V")) vars(starts_with("weight_"))
#test<-test %>% summarize_each(funs(sum), starts_with("V"))  
test<-test %>% summarize_at(vars(starts_with("V")),funs(sum))  
test<-as.data.frame(t(test))


insertRow <- function(existingDF, newrow, r) {
  existingDF[seq(r+1,nrow(existingDF)+1),] <- existingDF[seq(r,nrow(existingDF)),]
  existingDF[r,] <- newrow
  existingDF
}

#newrow <- 0
#test <- insertRow(test,newrow,3)
test<-as.matrix(test)
#cle_venti$newvar<-test[,1]
return(test)
}

cle_cor<-cle_ini[,1:7]
#Modif
cle_cor$cor_weight_code_30=as.numeric(correct_cle(cle_venti,"weight_code_30")+cle_cor$weight_code_30)

cle_venti[1,6:length(cle_venti)]<-t(cle_cor$cor_weight_code_30)

liste_col=colnames(cle_venti)[1:4]

```


### Calcul des clés finales

```{r message=FALSE, warning=FALSE}
# Boucle pour le calcul des clés finales
for (i in 1:length(liste_col))
{
  # Nouvelle variable de clé
  var<-stri_replace_all_fixed( paste("cor_",liste_col[i]), " ", "")
  #Variable sur laquelle calculer la clé
  code<-stri_replace_all_fixed(liste_col[i]," ","")
  # Construction de la variable
  cle_cor[[paste(var)]]=as.numeric(correct_cle(cle_venti,code)+cle_cor[[paste(code)]])
}
#??? déplacement en dernier position
cle_cor<-cle_cor%>%select(-cor_weight_code_30,cor_weight_code_30)

col_names<-colnames(cle_cor[,3:7])
cle_cor<-cle_cor[,-c(3:7)]
names(cle_cor)[3:length(cle_cor)]<-col_names
cle_cor<-cbind(cle_cor,cle_ini[,8:ncol(cle_ini)])

rm("cle_ini", "cle_int", "cle_venti","a","cle_fin","Charges_for_TA","couts_dir_indir")


```


```{r echo=FALSE}
#kable(couts_dir_indir[,-c(5:40)], format = "markdown")
kable(cle_cor, "html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  scroll_box(width = "1000px", height = "400px")
```


### Vérification des clés
```{r echo=FALSE}
#kable(couts_dir_indir[,-c(5:40)], format = "markdown")
kable(as.data.frame(colSums(cle_cor[,-c(1:2)]),col.names="Somme_cle"), "html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  scroll_box(width = "500px", height = "400px")
#View(as.data.frame(colSums(cle_cor[,-c(1:2)])))

#p <- ggplot(data=cle_cor, aes(x=Activite, y=weight_code_26)) +
#    geom_bar(stat="identity")
#ggplotly(p)
```


### Application des clés à la base des charges
Dans les étapes précédentes, nous avons calculer les pondérations de ventilation de toutes les activités sur les charges opérationnelles. </br>
Ces pondérations doivent être appliquée aux activités non opérationnelles pour avoir la cascade des coûts.

```{r message=FALSE, warning=FALSE}
code<-stri_replace_all_fixed( paste("charge_code_",cle_cor$Code_Activite), " ", "")
cle_cor<-cbind(code,cle_cor)

# Transposition de la table des clés
cols <- as.character(cle_cor$code)
test<-cle_cor[,-c(1,2,3)]
rownames(test)<-cols

t_cle_cor<-as.data.frame(t(test))
code<-row.names(t_cle_cor)

t_cle_cor$code<-substr(code, 8, 15)

## Fusion avec la base de charge

data_cascade<-left_join(data,t_cle_cor)

# Calcul de la ventilation sur les activités opérationnelles
data_cascade<-data_cascade%>% mutate_at(vars(starts_with("charge_code_")), funs(.*Ch_AP_Ret))

rm(list=ls()[! ls() %in% c("data_cascade","cols","fldc","Part_CVAE","Part_CFE","file.name", "path.to.file")])

```


Lorsque la variable concerne une charge opérationnelle, on met le montant de la charge après retraitement
```{r message=FALSE, warning=FALSE}

for (i in 1:length(cols))
{
  # Nouvelle variable de clé
  var<-cols[i]
  # Construction de la variable : Si le code est le même que la variable, on met la charge de la variable
  data_cascade[[paste(var)]]=ifelse(data_cascade$code== substring(cols[i],8),data_cascade$Ch_AP_Ret,data_cascade[[paste(var)]])
  
}

rm("cols","i","var")
```



# Répartition de la fiscalité locale de droit commun (FLDC)

La FLDC se répartie en deux temps: 

* Dans un premier temps il faut distinguer ,dans cette FLDC, deux parts. En effet, une partie de cette fiscalité sera répartie par une clé Masse Salariale alors que l'autre se verra appliquer une clé basée sur les charges de loyers. La clé de répartition permettant de déterminer ces deux montants est fournie par la direction de la Fiscalité.

* Ensuite, une fois ces deux montants obtenus, il s'agit de déterminer les clés permettant de répartir la fiscalité sur les Activités Opérationnelles concernées.

On doit donc calculer les clés de répartition pour la *FLDC*. Pour ce faire nous allons calculer les charges réparties sur les activités opérationnelles pour les natures de charge <span class="personnel et immobilier">function</span> . La FLDC concerne un certain nombre de rubrique corp qui ont été définis comme appartenant à la *FLDC*.

```{r message=FALSE, warning=FALSE}

# Fonction pour remplacer par zeros les NA
replace_0 <-function(x){
  ifelse(is.na(x),0,x)
}

# Remplacement des des charges opérationnelles par zéros lorsqu'elles sont manquantes
test<-data_cascade%>%mutate_at(vars(starts_with("charge_code_")), funs(replace_0))

# Somme colonnes des charges opérationnelles qui ont été ventilées
# Jointure avec le paamétrage des Rubriques corp concernées par la FLDC
test<-test%>%mutate(tot_charge_vent = rowSums(test[,grepl("charge_code_" ,names(test))]))%>%
                     left_join(fldc)

# Calcule de la charges FLDC totale à ventiler
charge_fldc<-sum(test[which(test$code=="code_59"),]$Ch_AP_Ret)

# Calcule de la part masse salariale de la FLDC
fldc_ms=Part_CVAE/(Part_CVAE+Part_CFE)
# Calcule de la part immobilier de la FLDC
fldc_im=Part_CFE/(Part_CVAE+Part_CFE)

# Construction des clés masses salariale par charge opérationnelle
t_MS<-test%>%
  filter(Nature_FLDC=="MS")%>%
  select(starts_with("charge_code_"))%>%
  summarise_all(sum)

t_MS<-as.data.frame(t(t_MS))%>% add_rownames()%>%
  mutate(code=substr(rowname,8,14))%>%
  mutate(cle_ms=V1/sum(V1),fldc_ms=V1)%>%
  select(code,cle_ms)


# Calcul des clés immobilier par charge opérationnelle
t_im<-test%>%
  filter(Nature_FLDC=="i")%>%
  select(starts_with("charge_code_"))%>%
  summarise_all(sum)

t_im<-as.data.frame(t(t_im))%>% add_rownames()%>%
  mutate(code=substr(rowname,8,14))%>%
  mutate(cle_im=V1/sum(V1),fldc_im=V1)%>%
  select(code,cle_im)                

# Calcule de la clé FLDC finale : cle_ms*fldc_ms+cle_im*fldc_im

cle_fldc<-t_MS%>%left_join(t_im)%>%
          mutate(cle_fldc=cle_ms*fldc_ms+cle_im*fldc_im,
                 charge=stri_replace_all_fixed( paste("charge_",code), " ", ""))



liste_col<-cle_fldc$charge

for (i in 1:length(liste_col))
{
  # Nouvelle variable de clé
  var<-liste_col[i]
  # Construction de la variable : Si le code est le même que la variable, on met la charge de la variable
  data_cascade[[paste(var)]]=ifelse(data_cascade$code=="code_59",
                                    data_cascade$Ch_AP_Ret*cle_fldc[which(cle_fldc$charge==var),]$cle_fldc,data_cascade[[paste(var)]])
  
}


data_cascade<-data_cascade%>%
              select(-c(charge_int,charges_tot_code,montant_no_prod_code))

# Affichage des clés FLDC
kable(cle_fldc, "html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  scroll_box(width = "1000px", height = "400px")


rm(list=ls()[! ls() %in% c("data_cascade","file.name", "path.to.file")])

```



Ce traitement marque ainsi la fin de la cascade.
On peut maintenat observer comment les charges se sont réparties sur les activités opérationnelles.

```{r message=FALSE, warning=FALSE}
table_pivot<-data_cascade%>%
  #mutate_each(funs(replace(., is.na(.), 0)),starts_with("charge_code_"))%>%
  mutate_at(vars(starts_with("charge_code_")),funs(replace(., is.na(.), 0)))%>%
  group_by(code,Lib_Code)%>%
  arrange(Code_manuel)%>%
  summarise_at(vars(starts_with("charge_code_")),funs(sum))

kable(table_pivot, "html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  column_spec(c(1,2), bold = T,color="white",  background = '#7030a0')%>%
  scroll_box(width = "1000px", height = "400px")

#write.table(data_cascade,file="sorties/data.csv",sep=";",dec = ",")

```


On peut maintenant télécharger toute la base de charges avec tous les résultats de la cascade:

* `charge_code_`sont les variables de ventiliation sur les activités o^érationnelles





```{r echo=FALSE}

data_cascade[is.na(data_cascade)]<-0

embed_data= function(x= data_cascade, filename= "file.csv", label= "Télécharger les données"){

  # Create encoded Base64 datastream 
  encode_data= function(x){
    write.csv(x, "./file.csv")
    enc= sprintf('data:text/csv;base64,%s', openssl::base64_encode(paste0(readLines("./file.csv"), collapse="\n")) )
    unlink("./file.csv")
    return(enc)
  }

  # String result ready to be placed in rmarkdown
  paste0("<a download='", filename, "' href=", encode_data(x), ">", label, "</a>")

}
```



```{r eval=FALSE, include=FALSE}

kable(data_cascade[sample(nrow(data_cascade), 30),], "html") %>%
  kable_styling() %>%
  scroll_box(width = "1000px", height = "400px")
#`r embed_data(data_cascade, filename="Resultats_cascade.csv")`
#`r embed_data(data_cascade, filename="data_cascade.csv")` 
```